[00:00] hey guys Greg here today I wanted to [00:01] talk about a very popular algorithm [00:03] known as recursive backtracking so as [00:05] kind of the name suggests it is going to [00:07] be recursive except particularly we [00:10] apply recursion in a way that does [00:12] something called backtracking and by [00:13] backtracking we basically just mean [00:16] you're going to make certain decisions [00:18] then after you make that decision you [00:19] would generally do some sort of [00:21] recursion on that so you make the [00:23] decision and then you basically move on [00:25] and this is recursion so at some point [00:27] you generally hit some sort of a base [00:29] case and at that point you would kind of [00:31] undo that decision that you made so we [00:33] make decisions but we know that we're [00:35] kind of able to undo those decisions and [00:38] so together this is basically called [00:40] recursive backtracking where you go and [00:42] you make decisions and you deal with [00:44] those decisions but then you undo them [00:46] at some point and generally the reason [00:48] for doing all of this it's generally to [00:50] do an exhaustive search so it's [00:52] basically like the definition of a Brute [00:54] Force technique it's basically whenever [00:56] you are asked something like if you want [00:58] to see all solutions so if you ever see [01:00] something like all then you would use [01:02] something like backtracking to generate [01:03] all the solutions okay so the best [01:05] example to explain backtracking would be [01:07] the subsets problem where again we're [01:09] looking for all the subsets so we're [01:11] given an integer array of nums of unique [01:14] elements and we need to return all of [01:17] the possible subsets aka the power set [01:20] so a subset of an array is a selection [01:22] of elements possibly none of the array [01:25] and the solution set must not contain [01:27] duplicate subsets and you can also [01:30] return the solution in any order so [01:31] basically what it's saying here is that [01:33] if you're given an array of numbers 1 2 [01:35] 3 we need to return all possible subsets [01:38] so you could choose no numbers you could [01:40] choose just one just two or just three [01:43] you could choose two numbers so you [01:44] could choose one and two 1 and three or [01:47] 2 and three or you could choose all of [01:49] the numbers so 1 2 3 and in total you'll [01:51] see here we actually have eight [01:53] Solutions so we're getting eight because [01:55] we'll see the math shortly but since [01:57] there is three different numbers here [01:59] and you could choose or not choose each [02:00] number you could actually get 2 to the 3 [02:03] which is equal to 2 * 2 * 2 which is [02:06] equal to 8 many solutions so we'll start [02:08] our solution as empty so there's nothing [02:10] so far and let's say we're considering [02:12] the number of one right now so since it [02:15] is subsets we could either choose that [02:17] number or we could not choose that [02:19] number so that basically means each time [02:21] we're going to have two different [02:22] branches so when we draw lines like this [02:24] it's really branches of this imaginary [02:26] tree so the left path we're going to [02:29] represent this left path as basically [02:31] don't choose so I'll put an X there as [02:33] in don't choose the number and this path [02:35] will be choose that number so on this [02:37] level we're considering the value of one [02:39] over here if we don't choose it our [02:41] solution is still empty and over here if [02:44] we do choose it okay well then so far [02:46] our solution is the list of one so at [02:49] this level here we're considering the [02:50] value of two and so if we don't pick [02:53] that number we still have nothing and if [02:55] we do pick that number then we have just [02:57] the list of two and over here if we had [03:01] instead picked one well then here if we [03:03] don't pick two then we end up with still [03:05] just one and if we do pick two then we [03:07] end up with one and then two we always [03:10] just place that new number on the end [03:12] like in a pend operation if we choose to [03:14] pick it okay so the last row here is [03:16] where we are considering the value of [03:18] three so over here if we picked nothing [03:21] well if we don't pick three then we [03:23] don't pick anything and this is actually [03:25] going to be a final solution over here [03:27] we are actually going to have just three [03:29] three over here we have two but we don't [03:32] pick three so it's just two over here we [03:35] do decide to pick three so we get two [03:37] and then three if we don't pick it it's [03:39] just one on the right path it is one and [03:42] then three and finally here we get 1 2 [03:46] and finally 1 2 and also three okay so [03:50] those are kind of in order here all of [03:52] our Solutions and we know that these are [03:55] solutions because basically here if [03:57] we're considering the value of one here [03:59] we're considering two here we're [04:00] considering three those are really all [04:02] of the numbers we have here and so we [04:04] could basically have like an index I for [04:06] example so at the first level I was here [04:08] then it was here and then it was here [04:10] and at the very end we'd actually get [04:12] out of bounds so this shows all the [04:14] different solutions that we'd get but we [04:16] didn't really draw it in the order that [04:18] the computer would actually go through [04:20] the solutions so here is how the [04:22] computer would do it it has to do these [04:23] things one at a time basically going to [04:25] do a DFS and so that's why we did a lot [04:28] of DFS tree problems s because this is [04:30] going to come up a lot so the path that [04:32] the computer would take here is [04:34] basically starting at this empty list [04:36] and then we are going to tell it to go [04:38] left first and left is don't pick the [04:40] number okay so basically if we're [04:42] considering the value of one here well [04:44] we're going to not pick it and so we end [04:46] up at empty we are going to do the same [04:48] thing again and so we're over here we [04:50] are then going to go left again we do [04:53] not pick two and so we end up over here [04:56] same thing again we actually go over [04:58] here and we don't pick three that is [05:00] when our index would then go out of [05:02] bounds after that and so we need to [05:04] backtrack it's called recursive [05:06] backtracking because our function is [05:07] recursive and when we hit a kind of [05:10] solution here it is then time to go back [05:12] up so we can do the other stuff so we go [05:14] back up here we are then going to go [05:17] down here we do all that stuff we come [05:19] back up here we then go over here and [05:22] then it's time to go right from here so [05:23] then we go over here we go here we go [05:26] back up and then we go to the right we [05:28] go back up and and from here we [05:30] basically just do this order here where [05:32] it looks like this so we'd visit all of [05:34] these nodes in this order this is just a [05:36] traditional depth for search now the way [05:38] we're going to go about this is [05:40] basically having two Global lists here [05:42] we'd have result which is eventually [05:44] going to be basically the list of all of [05:46] these Solutions it's going to have our [05:48] full answer the thing we actually want [05:50] to return and we'd also have another [05:52] Global list which I'm going to call S [05:54] and this is going to be a template for [05:56] pretty much all of our recursive [05:57] backtracking Solutions they're very very [05:59] similar and So Sol is basically this [06:02] list here it's a global that we're going [06:04] to change basically by appending numbers [06:07] so appending means take a number and pop [06:09] means to go basically back up here [06:11] because we need to undo that change that [06:13] we made that's the recursive [06:15] backtracking part so at the beginning [06:16] here both of these lists are empty and [06:18] so we are here we then decide to go left [06:21] we don't do anything we go left we don't [06:23] do anything we go left and then we hit [06:26] kind of this Leaf node here okay this is [06:28] a solution because our index is going to [06:30] go out of bounds and so we say okay well [06:33] result actually has a solution here we [06:35] basically give result here a copy of [06:39] solution then for Sol we are going to [06:41] back check up here and then here we say [06:44] actually let's pick three let's decide [06:46] to pick the value of three so when we do [06:48] that we temporarily append to Sol the [06:51] value of three saying okay we've picked [06:53] that number then we go and call our [06:55] function and recurse down that path and [06:57] we say oh we actually hit a base cas and [07:00] so same thing with result over here [07:02] we're going to give result a copy of [07:04] solution and so now it also has the list [07:06] of three now to properly recursively [07:09] backtrack this part we actually need to [07:12] pop three we decided to pick three here [07:15] but to recursively backtrack we need to [07:17] actually pop three by saying no no we [07:19] are going to undo that change that we [07:22] did which allows us to go back up here [07:24] so it's very important to understand [07:25] that we undid the change that we made [07:28] while going back up that is the [07:30] recursive backtracking part of this so [07:32] when we go back up here we are [07:33] considering now the value of two we [07:35] decide to pick two and so we temporarily [07:38] append to Sol two we are going to go to [07:40] the left here we hit a base case and so [07:42] result gets the list of two we go back [07:45] up and we say actually let's also use [07:47] the value of three and so we append [07:50] three as well so we get this and then we [07:53] are going to append that solution copy [07:55] to result you'll see why I'm saying copy [07:58] in a moment I'll explain that python [08:00] then when we go back up here we want to [08:01] say okay let's actually pop that from sa [08:04] so we're going to undo the fact that we [08:06] Ed three and then we are also going to [08:08] undo the fact that we used two so that [08:10] when we're at this level again we are [08:12] completely fresh that way when we're [08:13] back up here we can then go down this [08:15] path we would start to go down over here [08:17] and we'd end up appending the solution [08:19] of one and we'd end up going down this [08:21] path to basically fill up all of the [08:23] possible solutions and then at the end [08:24] of this we could return res okay so [08:27] let's code this solution up okay so we'd [08:29] start this off by getting n is equal to [08:31] the length of the numbers and in these [08:33] recursive backtracking Solutions you'll [08:35] almost always see we write res and S is [08:38] equal to an empty list each okay so they [08:41] are both going to start as these Global [08:43] empty lists where result is basically [08:45] the thing we're going to return at the [08:47] very end and solution is kind of one at [08:50] a time all of these different partial [08:51] solutions that we have now we're going [08:53] to define a function which we'll call [08:55] backtrack and it takes an index so [08:58] basically at the very beginning we'll [09:00] call this and I'll just do pass for now [09:01] so you can see it we'll end up calling [09:03] Backtrack on zero and that means just [09:06] start it at the very first index so [09:08] consider the value of one first and [09:10] after it does that it's going to go and [09:12] Traverse the whole imaginary tree [09:14] generate all of our Solutions and store [09:16] them in res and from there we're [09:18] actually going to be able to just return [09:20] res so let's write this backtrack [09:22] function so we know we're at a base case [09:24] or basically a leaf node if I is equal [09:27] equal to n so that is immediate when our [09:29] index goes out of bounds when we are [09:32] basically at the end of the array here [09:34] that's when we're at a base case and all [09:36] we need to do is just result. append a [09:39] solution copy notice that I'm saying [09:41] solution copy because if you just wrote [09:44] Sol here that would just give Rez a [09:46] reference to Sol you don't want a [09:48] reference you want basically a snapshot [09:50] in time of what solution is actually [09:52] storing so you need to do this which is [09:54] a copy of what solution is and from [09:57] there there's really nothing more we can [09:59] do here because our index is out of [10:00] bounds and so we are just going to [10:02] return now from here there's basically [10:04] two different paths that we want to go [10:06] down and to go down the left path first [10:08] which is don't pick don't pick nums at I [10:12] so basically we're considering nums at I [10:14] this is going to be don't pick it and so [10:16] we literally just say okay let's move on [10:19] let's call Backtrack on the next index [10:21] and deal with that and see what happens [10:23] but then after we go down that whole [10:24] path of not picking num at ey we should [10:26] also go down the path of pick num at I [10:30] and by pick it we need to do three [10:32] things we need to First actually pick [10:33] the number which means on SOL okay let's [10:36] append nums at I we just decided to use [10:39] that number let's now deal with that and [10:41] so we kind of just move forward here and [10:43] so we call Backtrack on I + one now [10:45] after we call this function here and we [10:48] return back to this stage here we want [10:50] to undo the fact that we picked nums at [10:52] I so here we temporarily pick it saying [10:55] okay let's pick it and move on but now [10:57] we're back here and we want to cursively [10:59] backtrack meaning undo these changes [11:02] that we did so that just means solution. [11:04] pop so that's going to pop that exact [11:07] same number that gets appended over here [11:09] and that is actually our code so if you [11:11] were to run and submit that that is [11:13] going to work okay so let's talk about [11:15] the time and space complexity of this [11:17] and for that we should go back to the [11:18] drawing board for a moment so regarding [11:20] the time complexity here well let's [11:22] basically count all of these things that [11:24] we're getting cuz that's basically each [11:26] call of the function so we have one here [11:29] here we have two at this level we have [11:31] four at this level and we have eight at [11:34] this level seeing a pattern yep that's [11:36] right if there was actually four numbers [11:38] here so if we had a four then that last [11:40] thing would be 16 so in other words this [11:43] level is basically two to the zero many [11:46] this is 2 to the 1 this is 2 to the 2 [11:48] and so over here it is 2 to the 3 it is [11:51] causing a doubling effect because of [11:53] these two branches we are basically [11:55] doubling every single level and so [11:57] because of that you could say that this [11:59] is roughly a 2 to the N solution so this [12:02] would be Big O of 2 to the N time [12:04] complexity tends to be a little more [12:06] laxed when you're talking about these [12:07] recursive backtracking Solutions because [12:09] it generates such a massive tree uh [12:12] luckily for subsets this is a known [12:14] mathematical problem and so it is [12:15] roughly going to be 2 to the end here [12:18] okay so that is the time complexity of [12:20] this solution what about the space well [12:23] of course we are storing all of this [12:25] stuff but that's part of the problem and [12:26] so we're not really going to consider [12:28] that as too much extra space really the [12:30] space that we're getting is from the [12:32] recursion recursion depth takes up space [12:34] because you have to store these call [12:36] Stacks and so what is the depth of this [12:38] recursion how far could it Go and so the [12:41] depth of our recursion is basically just [12:43] going to be however many numbers we have [12:45] so if we have n numbers then the space [12:47] complexity of this it's going to take up [12:50] roughly big go of n space due to the [12:53] recursive call stack I hope this was [12:55] helpful guys drop a like if it was and [12:57] have a great day bye-bye 